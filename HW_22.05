LEVEL 1

1.Что такое рекурсия?
  Процесс, в котором функция прямо или косвенно вызывает сама себя.
  
2. Что такое стек?
  Stack - линейная структура данных, которая следует определённому порядку выполнения операции.
      в Stack главное правило LIFO -последний зашел, первый вышел.
  
3. Какие типы рекурсии существуют? Каких нужно избегать?
  Прямая рекурсия - если функция вызывает ту же функцию
  Косвенная рекурсия - когда функция вызывает другую функцию, а другая функция прямо или косвенно вызывает первую.
  - Нужно избегать бесконечной рекурсии т.к. может привести к нехватке памяти (Stack Over Flow)
  
4. Когда стоит выбрать рекурсию, а когда цикл(итерацию)?
  Для рекурсии требуется больше памяти, но меньший размер кода
  А для Итерации больший размер кода, но не требует дополнительного места в Stack

5.Что обязательно нужно учитывать/добавлять при работе с рекурсией?
  Мы должны добавлять определённый случай, чтобы завершить процесс рекурсии(базовый случай)

6. Напишите рекурсивный метод для нахождения факториала числа 5! = 1 * 2 * 3 * 4 * 5
   int factorial(int n) {
        if (n == 0 || n == 1) {
            return 1;
        } else {
            return n * factorial(n - 1);
        }

   int result = factorial(5);
   System.out.println(result);
    

7. Напишите алгоритм Евклида через рекурсию
      while (a != b && a!= 0 && b!=0) {
            if (a > b) {
                a = a - b;
            } else {
                b = b - a;
            }
        }
        if (a == b) {
            return a;
        } else if(a == 0) {
            return b;
        } else {
            return a;
        }
      ------------------------------------  
        
 int algorithm(int a, int b) {
        if (b == 0) {
            return a;
        } else {
            return gcd(b, a % b);
        }

        int result = algorithm(a, b);
        System.out.println(result); 
    


LEVEL 2

1.Реализуйте алгоритм сортировки выбором (есть псевдокод на 4 слайде) Шаги алгоритма:
    - находим номер минимального значения в текущем списке
    - производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится 
        на данной позиции)
    - теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы
    
    function selectionSort(T[n] a) :
      for i = 0 to n -2
        min = i
          for j = i + 1 to n - 1
            if a[j] < a[min]
              min = j
      swap(a[i], a[min])
   ------------------------------------   
      
      ...
   
    
2. Реализуйте алгоритм сортировки вставками (есть псевдокод на 4 слайде) Алгоритм, 
    в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается 
    в подходящее место среди ранее упорядоченных элементов
    
    for i = 2 to n do
      x = A[i]
      j = i
      while (j > 1 and A[j - 1] > x) do
            A[j] = A[j-1]
            j = j-1
      end while
      A[j] = x
    end for
    
    --------------------------------------
    
    
    ...
