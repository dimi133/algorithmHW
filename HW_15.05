1. Как оценивается эффективность алгоритма?
    оцениваем по времени выполнения и объёму используемой памяти, а так же количества входных данных
    
2. Что учитывается при асимптотическом анализе?
    время и пространство (оцениваем скорость роста функции)
    
3. Перечислите основные правила асимптотического анализа
    - отбрасывается константа
    - оценка сложности произведения двух функций равна произведению их сложностей
        О(5n*n) = O(5n)*O(n) = O(n)*O(n) = O(n*n) = O(n2)
        
4. Какие порядки роста асимтотических функций знаете?
    - Константный - O(1) не зависит ото размера входных данных
    - Линейный - O(n) сложность алгоритма растёт с увеличением входного массива
    - Логариымический - O(log n) время выполненияалгоритма растёт логарифмически с увеличением размера входного массива
        (Алгоритм двойчного поиска)
    - Линейно-логарифмический - O(n log n) сортировка слиянием и быстрая сортировка
    - Квадротичный - O(nˆ2) зависит от квадрата размера входного массива
        (ПОВОД ПЕРЕПИСАТЬ АЛГОРИТМ)
    - Факториальный - O(n!) очень медленный алгоритм
    
5. Оцените сложность по времени и памяти
    void method(int n) {
        for (int i = 0; i < n / 2; i++) {                   // n/2 -> O(n/2) = O(n)
            for (int j = 1; j + n / 2 <= n; j++) {          // j + n / 2 <= n  -> j <=n/2    n/2 -> O(n/2) = O(n)
                for (int k = 1; k <= n; k = k * 2) {        // O(1) > O(..) < O(n).        O(log(n))
                    System.out.println("I am expert!");     // O(n) * O(n) * O(n) -> O(nˆ3).        -> O(nˆ2 * log(n))
                }
            }
        }
    }
    -----  ----- O(nˆ2 * log(n))
    
6. Оцените сложность по времени и памяти
    void method2(int n) {
        for (int i = 1; i <= n; i++) {                      // O(n)
            for (int j = 1; j <= n; j = j + i) {            // O(n)
                System.out.println("I am expert!");
            }
        }
    }
    ------ Квадротичная сложность ------- O(nˆ2)
    
7. Оцените сложность по времени и памяти
    void method3(int a, int b) { // примечание a > 0 и b > 0        //O(max(a,b))
        while (a != b) {
            if (a > b) {
                a = a - b;
            } else {
                b = b - a;
            }
        }
    }
    ------ Линейная сложность ------- O(max(a,b))
    
    
    
    
 Level 2
 сортировка пузырьковым методом (JAVA)
 int[] array = {6, 5, 3, 1, 8, 7, 2, 4};
 int n = array.length;
 int temp = 0;
 for(int i=1; i< n; i++){                       //O(n)
    for(int j=0; j<n-i; j++){                   //O(n)
        if(arrey[j] > arraz [j+1]){
        tepm = array[j+1];
        array[j+1] = arraz[j];
        array[j] =temp;
        }
        }
   szstem.out.ptintln(arrays.toString(array));
    }

-------> [1, 2, 3, 4, 5, 6, 7, 8]               // O(nˆ2)




